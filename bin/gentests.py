#!/usr/bin/env python

# This generates the empty shells for testing each sendable command.
# When adding commands, do not check in the generated file - just copy/paste
# the generated test into tests/irc/test_serialize_rfc2812.py and fill
# out the permutation matrix.

# if the command has a new param name, add it to GLOBAL_ARGS below.
import itertools
import os
import re
import typing as t
from pathlib import Path

from bottom.irc import KNOWN_COMMANDS, Command

HEADER = """
# ============================================================================
# THIS FILE GENERATED BY bin/gentests.py
# DO NOT CHECK THIS FILE IN.
# This generates the shell of a test class for every known command.
# From here, you should copy the test class into tests/irc/test_serialize_rfc2812.py
#   and then fill out the various fields to exercise permutations of the arguments.
# You should:
#   1. update any values in `arguments_map` to test specific inputs
#   2. add param lists to `permutations`
#   3. add to `expected_map` any names for expected strings.  these are used to check the outcome of each permutation.
# ============================================================================

from tests.helpers.base_classes import BaseSerializeTest
from tests.helpers.fns import base_permutations

""".strip()


TEMPLATE = """
class Test_{command.bottom}(BaseSerializeTest):
    # {command.syntax}
    # patterns:
    #   {patterns}
    # examples:
    #   {examples}
    command = "{command.bottom}"
    argument_map = [
        {argument_map_list}
    ]
    expected_map = {{
        "ERR": ValueError,
    }}
    permutations = base_permutations({permutation_index_list}, "ERR")
    permutations.update({{
        {permutations}
    }})
"""

GLOBAL_ARGS: dict[str, tuple[str, t.Any]] = {
    "channel": ("channel", "#chan"),
    "channel:comma": ("channel-list", ["#one", "#two"]),
    "count": ("count", 3),
    "distribution": ("distribution", "*.fr"),
    "info": ("info", "my-info"),
    "key:comma": ("key-list", ["key1", "key2"]),
    "mask": ("mask", "TODO"),
    "mask:comma": ("mask-list", "TODO"),
    "message": ("message", "msg msg"),
    "message:nospace": ("message-nospace", "msg.msg"),
    "mode": ("mode", "+i"),
    "modes": ("modes", "-io"),
    "nick": ("nick", "n0"),
    "nick:comma": ("nick-list", ["n0", "n1"]),
    "nick:space": ("nick-list", ["n0", "n1"]),
    "o:bool": ("o:bool", True),
    "params:space": ("params-list", ["+imI", "*!*@*.fi"]),
    "password": ("password", "hunter2"),
    "port": ("port", 1024),
    "query": ("query", "m"),
    "realname": ("realname", "my.realname"),
    "remote": ("remote", "*.edu"),
    "server": ("server", "tolsun.oulu.fi"),
    "target": ("target", "TODO"),
    "type": ("type", 3),
}
ARG_RE = re.compile(r"\{(.*?)\}")


def gather_args(command: Command) -> list[str]:
    args = []
    for pattern in command.patterns:
        for arg in ARG_RE.findall(pattern):
            if arg not in args:
                args.append(arg)
    return args


def lookup_arg(arg: str) -> str:
    try:
        raw = GLOBAL_ARGS[arg]
    except KeyError:
        print(f"unknown param key {arg} -- is it missing from GLOBAL_ARGS?")
        raise
    return f"{raw!r},"


def gen_permutations(n: int) -> t.Iterable[tuple]:
    ids = list(range(n))
    for r in range(n + 1):
        yield from itertools.combinations(ids, r)


def render_permutations(arguments: list[str], indent: int, placeholder: str) -> str:
    out = []
    for permutation in gen_permutations(len(arguments)):
        out.append(f"{permutation!r}: {placeholder!r},")
    sep = "\n" + " " * indent
    return sep.join(out)


def render_test_class(command: Command) -> str:
    arguments = [lookup_arg(arg) for arg in gather_args(command)]
    permutation_index_list = repr(list(range(len(arguments))))
    permutations = render_permutations(arguments, indent=8, placeholder="TODO")
    return TEMPLATE.format(
        command=command,
        argument_map_list="\n        ".join(arguments),
        patterns="\n    #   ".join(command.patterns),
        examples="\n    #   ".join(command.examples),
        permutation_index_list=permutation_index_list,
        permutations=permutations,
    )


def check_commands(commands: list[Command]) -> None:
    n = len(commands)
    group = {}
    for command in commands:
        group.setdefault(command.bottom, []).append(command)
    n_collide = sum((1 for v in group.values() if len(v) > 1))
    print(f"{n} commands defined, {n_collide} collisions")
    if n_collide:
        print("ERROR: following commands collide on Command.bottom:")
        for each in group.values():
            if len(each) > 1:
                for command in each:
                    print(command)


def main(dst: Path) -> None:
    out = [HEADER]
    for command in KNOWN_COMMANDS:
        out.append(render_test_class(command).strip())
    all = "\n\n\n".join(out) + "\n"
    dst.parent.mkdir(exist_ok=True)
    dst.write_text(all)
    check_commands(KNOWN_COMMANDS)


if __name__ == "__main__":
    root = (Path(os.path.dirname(__file__)) / "..").resolve()
    dst = root / "build/generated.py"
    main(dst)
